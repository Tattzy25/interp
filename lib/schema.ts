import { z } from 'zod'

export const fragmentSchema = z.object({
  commentary: z
    .string()
    .describe(
      `Describe what you're about to do and the steps you want to take for generating the fragment in great detail.`,
    ),
  template: z.string().describe('Name of the template used to generate the fragment.'),
  // template_ready: z.boolean().describe('Detect if finished identifying the template.'),
  title: z.string().describe('Short title of the fragment. Max 3 words.'),
  description: z
    .string()
    .describe('Short description of the fragment. Max 1 sentence.'),
  additional_dependencies: z
    .array(z.string())
    .describe(
      'Additional dependencies required by the fragment. Do not include dependencies that are already included in the template.',
    ),
  has_additional_dependencies: z
    .boolean()
    .describe(
      'Detect if additional dependencies that are not included in the template are required by the fragment.',
    ),
  install_dependencies_command: z
    .string()
    .describe('Command to install additional dependencies required by the fragment.'),
  // install_dependencies_ready: z.boolean().describe('Detect if finished identifying additional dependencies.'),
  port: z
    .number()
    .nullable()
    .describe('Port number used by the resulted fragment. Null when no ports are exposed.'),
  file_path: z.string().describe('Relative path to the file, including the file name.'),
  code: z.string().describe('Code generated by the fragment. Only runnable code is allowed.'),
  // code: z.array(z.object({
  //   file_name: z.string().describe('Name of the file.'),
  //   file_path: z.string().describe('Relative path to the file, including the file name.'),
  //   file_content: z.string().describe('Content of the file.'),
  //   file_finished: z.boolean().describe('Detect if finished generating the file.'),
  // })),
  // code_finished: z.boolean().describe('Detect if finished generating the code.'),
  // error: z.string().optional().describe('Error message if the fragment is not valid.'),
})

export type FragmentSchema = z.infer<typeof fragmentSchema>

// Build persistence schemas (client-side typing helpers for Supabase tables)
export const buildSchema = z.object({
  id: z.number().optional(),
  user_id: z.string().nullable().optional(),
  team_id: z.string().nullable().optional(),
  template: z.string().nullable().optional(),
  title: z.string().nullable().optional(),
  description: z.string().nullable().optional(),
  file_path: z.string().nullable().optional(),
  sbx_id: z.string().nullable().optional(),
  url: z.string().nullable().optional(),
  created_at: z.string().optional(),
})

export type Build = z.infer<typeof buildSchema>

export const buildFileSchema = z.object({
  id: z.number().optional(),
  build_id: z.number(),
  file_path: z.string(),
  content: z.string(),
  created_at: z.string().optional(),
})

export type BuildFile = z.infer<typeof buildFileSchema>

// Optional payments schema to support future entitlements
export const paymentSchema = z.object({
  id: z.number().optional(),
  user_id: z.string().nullable().optional(),
  team_id: z.string().nullable().optional(),
  provider: z.string().nullable().optional(),
  provider_payment_id: z.string().nullable().optional(),
  amount: z.number().nullable().optional(),
  currency: z.string().nullable().optional(),
  status: z.string().nullable().optional(),
  created_at: z.string().optional(),
})

export type Payment = z.infer<typeof paymentSchema>
